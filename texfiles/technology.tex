\chapter{Technology}
\label{chap:Technology}
\todo[inline]{Write technology}

\section{Serving}
\label{sec:Serving}
We can choose to serve the data in multiple ways, even after we have decided that the first focus will be to make a website be the place the user goes to get the data. We can go with static serving which is what sub section~\ref{sub:Static serving} will focus on, or we could go with a web service, and then go with a single page application or similar technology to present the data, which is what sub section~\ref{sub:Web service} will discuss.

\subsection{Static serving}
\label{sub:Static serving}

One way to implement the website could be purely via static serving. This means that the server will receive a request from the client to which the server then finds the appropriate HTML, CSS and potentially JavaScript files to give back, and the browser then renders this for the user.

Because of our requirements in regards to user verification and database dependent data we cannot go with the purest static serving model. We can however use technologies such as PHP, ASP.NET, or spring. Two of which are not C\#, which was another goal for the project, to support maintainability within IT-minds.

Sprint is based on the JVM\cite{spring-framework}, which means that you would need to run in languages that uses this virtual machine in order for it to work. Some languages that could use Spring would be Java or Scala, where most in IT-minds would be able to develop in Java, since it is similar to C\# on a lot of points. And most of the people working in IT-minds have build things in Java before.

If we were to create the service with Java we could support different operating systems to host the server out of the box, which can be convenient when trying to find cheap hosting.

For the most part the universal support for hosting is also true for PHP. PHP is a server scripting language\cite{php-home}, designed to support web development well. It can be integrated into ones HTML pages, and from there insert new HTML. The user will never see the logic of PHP, like they would never see it for Spring, as when the request is made to the server the code is evaluated, and the template is pre-rendered, which means the results of the template values are inserted, and what the client gets is only the pure html. This can be an advantage since we don't show any internal logic because of this.

ASP.NET work much in the same way that Spring does except it runs on the .NET virtual machine made by Microsoft, A few different languages run on the .NET virtual machine, similar to different languages runs on the JVM, one of these languages is C\# which is very popular language in IT-minds, and amongst their customers.

ASP can also use the template option, where they render some code on the server before it is sent to the user, who will have no idea which parts are hardcoded and which are dynamic.

In previous versions of .NET the user was mostly locked on to the windows platform, with a few exceptions like mono\footnote{Read more about the mono project at: http://www.mono-project.com/}. But recently Microsoft has decided to start supporting other platforms, as part of their open sourcing of parts of the .NET platform\cite{.net-core}, in a push to make ASP.NET 5 more modular and open.

\subsection{Web service}
\label{sub:Web service}
Another option could be to create a web service, that will then expose the data in a way for clients to call to, allowing for multiple different frontends to be implemented, with the web service as the way of getting hold of the data.

The advantage of using a service for a setup such as this one, would be that if for some reason the website needs to be updated with a new look, that can be done without ever touching the backend. Another advantage is that we can make multiple different clients communicating with the same service, meaning we can decide later on that we also want to support a mobile application. This can be done entirely from an exposed interface, without the mobile developer ever having to look at the backing code, only the documentation of the interface.

There are a couple of different web service types, two of which I will discuss in this section.

\subsubsection{SOAP}
\label{subs:SOAP}
SOAP\footnote{Simple Object Access Protocol} is a type of web service which relies on sending data in XML.

The goals of SOAP is to be extensible and simple at the same time\cite{soap:messaging}. This means that a lot of features that is often used in order for the messaging to work correctly such as correlation and routing is not part of the basic SOAP messaging protocol, bit the protocol is made so that it can support them with extensions. An advantage of this is also that SOAP is not bound to a specific protocol for sending the data, and can therefore be implemented to use whatever is best suited for the situation.

In soap you send all the data in an XML envelope, containing an optional header section and a body section, the header section is for data that extends the basic SOAP protocol, such as information of priority or correlation between messages\cite{soap:messaging}. This section is there to make the entire protocol modular, and extensible. Where the body is for the message itself, and there for the core of the protocol to have a use.

The body of a SOAP message is where the data is contained, in a successful scenario the body contains whatever was expected for the client to get. But it can contain a fault as well, meaning something went wrong in the transaction. The fault holds information on what type of error happened, so that it can be handled. The faults are identified with fault codes, which can hold sub codes to specify deeper what the problem in this particular instance was. These fault codes are part of the application domain, so a code could be "NoCompany" and a client receiving that code would then know exactly what when wrong, which in this case would be that there is no company available.

The primary argument against using SOAP is that the initial frontend will be a website, which means that we will have to either combine one of the static serving ways with the SOAP service, or have to have JavaScript call the service. If we go with a setup where we have JavaScript call the service the JavaScript has to use some extra energy on translating the XML into the data structures of JavaScript, which is JSON.

\subsubsection{RESP}
\label{subs:RESP}
An alternate type of web services is a REST API, which stands for Representational state transfer. A REST API generally communicate via the http protocol. This limits a little compared to SOAP, as described in sub section~\ref{subs:SOAP}, which can work with any protocol.

The appeal of a web API is the simplicity, as the http protocol is so well established, with error codes for most situations, and the added ability to give reasons on top. Another reason is that since it runs on HTTP it makes sense to use the often already set up rules for firewalls and so forth, to allow calls to websites to go through.

The body of the simplest call is limited to only a verb and the url to which we want to call, where in SOAP we need to set up an entire request body.

As we surf the web we can get all sorts of different datatypes, all the way from a simple text file to a binary file. This is something RESP APIs allow as well, which means that instead of having the resource locked to come in XML format we can send it as ex. JSON, or some other format that we see fit\cite{rest:basic}. Because we can never really be sure that the caller is not malicious and try to format or break the communication be changing the sent data the type safety that XML gives is not as important as we have to verify everything anyways.

As with SOAP in REST we can have headers carry extra data, such as what format we would like the response to be in, and the token for authentication the user has. This is a feature supported and used by standard web servers and browsers when we surf the internet, so REST just decided to keep using this as well.

There are some rules for a web API to be called RESTful\cite{rest:msdn}, for this to be true the paths have to follow some fairly simple rules. If we want to get a list of eg. activities we would call a path that ends with "/activities" with the verb "GET". If the RESP API has a resource type on the path activities it will return a list of all of them with the status code 200 which stands for OK. When we then want a specific one we call "/activities/id" with the verb "GET" where id is the id of the activity we want.

This is only the read part of CRUD, but the other parts are also supported. They just use different verbs, the most common are "POST" for create, "PUT" for updating, although "PATCH" could also be used for that, and "DELETE" for deleting an element. If it is an existing resource you are operating on, the address should end in the id of the resource to be worked on, and otherwise just in the resource type, such as the first get.

Another rule for a service to be called REST is that it has to be state less, which means that one request cannot be dependent on another to be done first, as the system is not allowed to keep the state of a call. If we want to update a resource we are allowed to get the resource first, but it should not be required, and we cannot know if someone else have removed the resource between un getting it and trying to update it. Because of this it is important to return the right error codes when something goes wrong, as it is then clear what went wrong.

The important thing is that within one connection we do not make multiple calls to the server, as that would mean that we have a connection state. The client is allowed to have a state of its own, in fact the client does not have to abide by any of the REST rules for it to communicate with a REST server, except for in the communication itself. The server will often keep a state as well in that the data is often stored somewhere which means that the data is in a state.

Another rule is that the resources must be cacheable, meaning that the protocol holding the data must have some way of allowing caching. Since http is the most common protocol this is generally done with the cache-control headers\cite{rest:elkstein:architeture}.

Lastly the system must be layered\cite{rest:uci}, meaning that it is only allowed to know its immediate neighbors. Say a REST service needs to pull data from another service that is pulling from some legacy service, the REST service is not allowed to skip the first service because this would mean that it is communicating with a layer deeper than its immediate neighbor. The reason for this is that it cannot end up in a situation where we have the middle layer ex. employing some extra security before the last layer that is now skipped. It also enforces some organizational bounds, and keeps the service structure clean.

\subsection{Chosen type }
\label{sub:Chosen type}
Based on the arguments for and against the different technologies, and the requirement that IT-minds needs to be able to continue development after this project is done. And a little bit of my own interest, I have come to the conclusion that the best way of serving the data is via a RESTful API. There are a couple of reasons for this conclusion. First of which is the possibility for me to use the language I see best fit. Another reason is also that a CRM could be useful as a mobile app at a later time, and that would need some API to talk to in order for it to the same backend as the website.

The reason of going with a RESTful architecture instead of SOAP is two parted. First off in IT-minds most of our customers are looking for RESTful more often than SOAP, since it is easier to work with, leading to the developers having more experience in developing such a system, myself included.

The other reason is that JSON is easier to parse than XML in a lot of languages, and is the data structure of  JavaScript which is going to be what will be driving the logic of the web frontend, so the frontend will not need to parse it at all.

The implementation of the RESTful service will be made using ASP.NET since I have experience in it and it is well suited for such a task. It will however limit the systems it can run on, as I will not be using ASP.Net Core 1 which can run on systems with Linux on them\cite{asp5:intro}.

The reason I have chosen not to go with Core 1, but webapi 2, which still runs on ASP.NET, is because it is still only in release candidate\cite{asp_core_1:roadmap}, and to my experience it is still missing some of the features related to authentication on a web api setup, which will be required in this project.

\section{Database }
\label{sec:Database_engine}
When I comes to which database to use, there are a lot to take into account. First off we need to look at what type of database we want. When we have decided this, we need to figure out which engine for the database we are going to go with.

This analysis will not be exhaustive as there are a lot of different types, but I will look at some of the most common.

\subsection{Relational database}
\label{sub:Relational database}
One type of database is the relational database. This type of database has all the data stored in tables, where there will be some sort of key, allowing a table to be connected to another. The advantage of this is that they can reduce a lot of redundant data by storing in different tables, and then having multiple entries pointing at the same column\cite{ibm:choosing_dbms}.

An important aspect when working with relational databases is the idea of normalization. This is a way to reduce redundancy, and thereby the possibility of inconsistent data.

\subsection{Object database}
\label{sub:Object database}
This form of database is designed to resemble the way a data is structured in object oriented programming languages such as Java, C++ or C\#. This means that the data is structured in classes, that can inherit from one another. The idea is that the API to the database makes sense for object oriented languages.

The risk with using this form of database is that it is easy to fall into the same design patterns as one would in the application itself, which may not be as efficient when it comes to a database, as they may require more resources, or time\cite{ibm:choosing_dbms}.

\subsection{Document database}
\label{sub:Document database}
A document database is a database that instead of saving in tables it saves the data in documents. The structure can vary, but initially most of these databases stored their data in XML\cite{ibm:choosing_dbms}. Now JSON and variants there off has started to show up for some database systems.

The advantage of this form of database is the lack of structure, as it allows for a more accepting storage for the users. The primary drawback of document databases is that they are generally not as efficient as other database systems, they take up more space, and the queries can be slow to set up\cite{ibm:choosing_dbms}.

It can be a good type of database for some web applications, especially if some parts of the database is kept structured.


\subsection{Decision }
\label{sub:database_decision}
For this project I have decided to use a Relational database, as it has fast queries, and the structure enforces a valid model. Since the application is developed as a web API in C\# using ASP.NET it makes sense to use MsSQL for the specifik engine, as this is a natively supported database in the entity framework, which is the recommended data-access framework when using C\# acording to Microsoft\cite{entity:microsoft}.

MsSQL also makes sence as it is proven to work for others in a lot of scenarios, based on its usage\cite{obdms:gartner}.

\section{Frontend}
\label{sec:Frontend}
For the frontend there are a few different ways we can go. Because of our decision to go with a web API for the backend we need some dynamic way of handling the remote calls to the server.

Because we are working in a browser it makes since to go with JavaScript, as this is a scripting language supported by most modern browsers. Even in this we still have a lot of options as to how to handle the calls. There are a lot of options for frameworks as well. Which allows us to develop with different structures, such as MVVM\footnote{Model View ViewModel} and MVC\footnote{Model View Control}, and some others.

Some of the options that follow the MVC model is AngularJS and EmberJS. Angular is made by google\cite{angularjs}, and allows us to separate the application out into separate parts, having a controller per view. We can also separate functions into services, and create directives, a directive is a view element, that allows us to reuse elements for the website in different places on the site without having to rewrite the code over and over again.

Ember allows for many of the same things as angular, but has not been around as long, and handles the things slightly differently\cite{emberjs}.

They both have a templateing language implemented to allow integration, and databinding with the HTML view. This allows both for the data to live and be updated by the JavaScript, as well as having control structures in the HTML such as loops and conditionals, to allow for a more dynamic experience without having to deal directly with JQuery or the document object of the window object.

Because my focus in this project is not on the frontend, but to make the backend so that different frontends will be able to use it I have decided to go with AngularJS as that is the one I have the most experience with, and it has a lot of modules build by different people that can be used to make the experience a little better.

\section{Chapter summary }
